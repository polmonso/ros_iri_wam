TrajectoryPlannerROS:

# Robot Configuration Parameters

  max_vel_x: 0.5
  min_vel_x: 0.2
  max_rotational_vel: 0.3
  min_in_place_rotational_vel: 0.2
  escape_vel: -0.3

  acc_lim_th: 0.5
  acc_lim_x: 0.5
  acc_lim_y: 0.0

  holonomic_robot: false

# Goal Tolerance Parameters

  # The tolerance in radians for the controller in yaw/rotation when achieving its goal
  yaw_goal_tolerance: 0.1
  # The tolerance in meters for the controller in the x & y distance when achieving a goal
  xy_goal_tolerance: 0.25
  # If goal tolerance is latched, if the robot ever reaches the goal xy location it will
  # simply rotate in place, even if it ends up outside the goal tolerance while it is doing so
  latch_xy_goal_tolerance: true

# Trajectory Scoring Parameters

  # Whether to use the Dynamic Window Approach (DWA)_ or whether to use Trajectory Rollout
  # (NOTE: In our experience DWA worked as well as Trajectory Rollout and is computationally
  # less expensive. It is possible that robots with extremely poor acceleration limits could gain
  # from running Trajectory Rollout, but we recommend trying DWA first.)
  dwa: false

# The cost function used to score each trajectory is in the following form:
# cost =
# path_distance_bias * (distance to path from the endpoint of the trajectory in map cells or meters depending on the meter_scoring parameter)
# + goal_distance_bias * (distance to local goal from the endpoint of the trajectory in map cells or meters depending on the meter_scoring parameter)
# + occdist_scale * (maximum obstacle cost along the trajectory in obstacle cost (0-254))

# http://www.ros.org/wiki/navigation/Tutorials/Navigation%20Tuning%20Guide

  # Whether the goal_distance_bias and path_distance_bias parameters should assume that
  # goal_distance and path_distance are expressed in units of meters or cells.
  # Cells are assumed by default. New in navigation 1.3.1
  #meter_scoring (bool, default: false)

  # The weighting for how much the controller should stay close to the path it was given
  #path_distance_bias: 0.6
  # The weighting for how much the controller should attempt to reach its local goal, also controls speed
  #goal_distance_bias: 0.8
  # The weighting for how much the controller should attempt to avoid obstacles
  #occdist_scale: 0.01
  # How far to look ahead in meters when scoring different in-place-rotation trajectories
  #heading_lookahead: 0.325
  # Whether to score based on the robot's heading to the path or its distance from the path
  # heading_scoring_timestep (double, default: 0.8)
  # How far to look ahead in time in seconds along the simulated trajectory when using heading scoring
  #heading_scoring: false

  #publish_cost_grid: true

# Oscillation Prevention Parameters

  # How far the robot must travel in meters before oscillation flags are reset
  # Global Plan Parameters
  #oscillation_reset_dist (double, default: 0.05)

  # Defines whether or not to eat up the plan as the robot moves along the path.
  # If set to true, points will fall off the end of the plan once the robot moves 1 meter past them.
  #prune_plan (bool, default: true)

# Forward Simulation parameters

  # The amount of time to forward-simulate trajectories in seconds
  sim_time: 1.0 # MARTI: segons answers 763
  # The step size, in meters, to take between points on a given trajectory
  #sim_granularity: 0.025
  # The step size, in radians, to take between angular samples on a given trajectory.
  angular_sim_granularity: 0.08 # MARTI: test rotacio lenta. 5dg
  # The number of samples to use when exploring the x velocity space
  vx_samples: 15 # MARTI: segons answers 763
  # The number of samples to use when exploring the theta velocity space
  #vtheta_samples: 20
  # The frequency at which this controller will be called in Hz.
  # Uses searchParam to read the parameter from parent namespaces if not set in
  # the namespace of the controller. For use with move_base, this means that you
  # only need to set its "controller_frequency" parameter and can safely leave
  # this one unset.
  controller_frequency: 10.0 # MARTI: per evitar error que no arriba a la freq. desitjada

